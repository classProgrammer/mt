\section{Chatbot}
A chatbot is a conversatinal agent able to communicate with a user using natural language 
\cite{evaluateChatbotsShawar2007, shawar2007chatbots, huang2007extracting, gregori2017evaluation}.
The term chatbot is a combination of the words chatting and robot.
In literature synonyms like chatterbot and conversational agent are used.
The communication with a chatbot is most often done in written form like in a chat but not restricted to it since 
speech is also classified as natural language.
The communication between man and machine is done in turns until a conversation end is reached 
or the conversation is aborted \cite{vrajitoru2004evolutionary}.
A conversation end is when the underlying tasks has been achieved.
The user input is interpreted by the chatbot and the most likely response is generated \cite{dutta2017developing}.
In the best case the generated response is reasonable and intelligent \cite{vrajitoru2004evolutionary}. 
In the worst case a generic message like "I didn't understand that" is generated.
It's important to keep in mind that a chatbot is able to mimic intelligence, human dialog, 
and personality but is often limited to specific functionality \cite{kane2016role, dutta2017developing}.

Three major chatbot types are present in literature.
There are menu-driven chatbots (\citet{singhbuilding}), domain-specific/goal-oriented chatbots (\citet{deshpande2017survey, luis2015williams, braunEvaluatingNLU, williams2017hybrid}),
and chatbots for general/open-ended conversations (\citet{brandtzaeg2018chatbots, singhbuilding}).
Menu-driven chatbots mimic a classical interface and navigate the user through the 
interface using text or speech.
An example for a menu-dirven chatbot is a phone call at a support hotline.
The caller is guided through the interface by the system and isn't connected to a person immediately.
The system gives options like "press one if you'd like to request a refund, press two 
if you need replacement parts", navigates the caller through the process, collects information like the order number, and 
connects the user to the correct department.
Domain-specific chatbot offer function limited to a domain.
Such systems provide the functionality to achieve specific tasks and are not supposed to handle anything else.
One example would be a refund desk in a shop.
If the customer asks for refund specific information or wants to issue a refund the customer is served.
If the customer asks where the TVs are located in the shop he is redirected to the information counter.
A chatbot system in the refund desk domain offers only the functionalty necessary to get and collect refund information, 
and to issue a refund. If the bot is asked something else no useful response can be expected.
Open-ended systems are made for a general conversation.
Contrary to the other two approaches the user can ask open-ended systems anything and the most likely response is generated.
There are no fixed rules what users may or may not ask and the conversation can develop in any direction.
These systems have a hard time to collect specific information since there is no way to tell which information is needed.
Every conversation can vary greatly hence no information can be presumed.
Popular examples for open-ended systems are Google Home, Siri (Apple), and Alexa (Amazon) \cite{singhbuilding}.
The most limited approach is the menu-drive approach since the options are given and a user only inputs numbers to select a functionality.
Domain-specific bots communicate with users in natural language and are good in achieving tasks and collecting information.
Open-ended systems are perfect for general communication, are not restricted to a domain but it's hard to collect specific information
or achieve a specific task with such systems.
A simple exemplary chatbot conversation is shown in Figure \ref{fig:faqexamplecrop}.

In general, a chatbot system consists of rules and training data.
The training data is used to train the natural language capabilities and 
should be as realistic as possible.
The training data can be handcrafted for prototyping or generated from large sources like emails, phone calls,
or the internet.
The rules define the available functionality, types, and possible input statements.
One simple rule could be that a person name is required as input and needs a first and last name to be formed.


\section{Chatbot/NLU Frameworks}
Many chatbot and NLU frameworks were created to enable non ML experts to 
develop chatbot systems.
The frameworks can be devided in cloud-based and local solutions.
The cloud based solutions are created, edited, and developed a browser window 
and are used via a REST API endpoint.
The developer is dependent on the provider and the training and analysis is done 
in the coud of the provider. This needs to be kept in mind for security critical 
information.
The big cloud providers offer chatbot or NLU frameworks in their cloud environment.
Microsoft has LUIS (\citet{luis2015williams, luisdocs}),
Google develops Dialogflow (\citet{dialogflow}),
IBM offers Watson Assistant (\citet{watsonassistant}),
Amazon provides Lex and Alexa.
The local solutions are standalone applications running on the development machine or 
the company server.
The data is never passed to another computer or a cloud environment.
A popular local open-source solution is Rasa (\citet{rasabocklisch2017,rasa}). 


\section{Suitable Problems for Chatbots} 
Chatbots seem like intelligent systems capable of natural language conversation \cite{buiildChatbotsPython}.
Most often they are design for specific tasks and definitely not intelligent \cite{buiildChatbotsPython}.
Chatbots are not able to solve complex problems \cite{buiildChatbotsPython}.
Therefore, not every problem can be solved using chatbots \cite{buiildChatbotsPython}.
In general, a problem is suitable for chatbots if the following questions need to be answered \cite{buiildChatbotsPython}.
Can the problem be represented with simple questions and answers and Back-and-Forth communication \cite{buiildChatbotsPython}.?
Chatbots use natural language which works through back and forth communication.
Is the problem a highly repetitive issue that requires data-fetching or analyzing? 
Bots are made to do highly repetitive tasks to reduce the workload of humans \cite{buiildChatbotsPython}.
It makes no sense to create a chatbot for non-repetitive task since then the chatbot development costs never pay off. 
Can The problem be automated and fixed \cite{buiildChatbotsPython}?
It the problem can't be automated the work must be done by an employee again and the chatbot has not reduce the workload and is irrelevant.
If the answer to all questions is yes the problem is perfect for a chatbot application \cite{buiildChatbotsPython}.
A simple QnA bot for a FAQ page of a website is an example of a suitable problem \cite{buiildChatbotsPython}.
The task can be automated, is highly repetitive and the answers are predefined.






\section{Intent} \label{sec:intent}
A user interacts with a chatbot with an intention in mind \cite{buiildChatbotsPython, singhbuilding}.
The intent is the action a user wants to perform \cite{dutta2017developing, rahman2017programming}.
The intent can be found by answering the question: "What is the user asking for?" \cite{buiildChatbotsPython}.
The identification of intents is the essential function of any chatbot system \cite{singhbuilding}.
In AI-based chatbots intents are detected via NLP \cite{singhbuilding}. 
The NLP systems return a confidence score for a user query.
The confidence score is an indicatior how good the user inpur matches the training data used to train the intent.
A high score indicates a good match.
The model provides a confidence score for each question telling you how 
confident the algorithm is that the correct intent has been found \cite{buiildChatbotsPython}.
A use-case dependent border value can be defined for the confidence score e.g. 50\%. 
Every value above 50\% confidence is treated as the specified intent.
Everything below 50\% is treated as a failure and the fallback intent comes into play.
As a fallback a message like "I'm sorry but I didn't get that" can be used.
The following examples demonstrate what intents are and how they could be named using the
example sentences of Table \ref{tab:example_sentences}.
In example sentence one of Table \ref{tab:example_sentences} the intent can be labeled as 
"Greeting\_Intent" since the user greets the bot.
Example sentence two of Table \ref{tab:example_sentences} shows that the user wants to book
a hotel room and the intent could be labeled "Book\_Hotel\_Intent" in this case.
Figure \ref{fig:defaultwelcomedialogflow} shows the default welcome intent created by Dialogflow. 

\makefigure{defaultwelcomedialogflow}{Default Welcome Intent of Dialogflow}


\section{Utterance} \label{sec:utterance}
An utterance is a sentence or a part of a sentence.
All sentences of Table \ref{tab:example_sentences} are utterances.
The input of users are utterances \cite{singhbuilding, dutta2017developing}.
Chatbot systems also answer users with utterances and they are also used to train the NLP system.
A collection of utterances belongs to an intent and builds the base for the classification of user input.
Utterances which belong to an intent are different versions of the same question \cite{buiildChatbotsPython}.
With the different versions of the same question the model of the chatbot is trained.
Thanks to the knowledge gained from multiple utterances per intent the chatbot is able to
classify sentences correctly which never were part of the training data.
Example sentence two of Table \ref{tab:example_sentences} can be used as utterance for the book hotel intent.
Utterances need to be chosen with care to prevent overfitting to unimportant features of the sentences.
If all utterances contain a specific word at a specific position the model likely assumes that it must be like this all the time.
The default utterances of the welcome intent of Dialogflow can be seen in the training phrases section in Figure \ref{fig:defaultwelcomedialogflow}.

Utterances for training purposes can come from multiple sources.
They can be handcrafted for development and test purposes.
The data can come from live systems.
Real user input from e.g. e-mails and phone conversations can be used to get a large amount of training data \cite{singhbuilding}.    


\begin{table}[H]
    \centering
    \begin{tabular}{ c | l | c | l }
        No. & Sentence & Intent & Entities \\ \hline \hline
        1 & Hello & Greet & - \\ \hline
        2 & I'd like to book a hotel & Book Hotel & - \\ \hline
        3 & The Twelve Months hotel & - & Hotel Item\\ \hline
        4 & From the 27th of April & - & Date From\\ \hline
        5 & To the 4th of May & - & Date To\\ \hline
        6 & Ethan May & - & Person Name\\ \hline
        7 & Order one green t-shirt size M please & Place Order & T-Shirt Item, Color, Size \\ \hline
    \end{tabular}
    \caption{Examples for Concept Explanation} \label{tab:example_sentences}
\end{table} \noindent

\section{Entity} \label{sec:entity}
In the area of chatbots an entity is an interesting pice of information which needs to be 
extracted from the conversation.
They are metadata belonging to an intent and can be represented in different ways \cite{buiildChatbotsPython}.
Entities can be volumes, counts or quantities for instance \cite{buiildChatbotsPython}.
It is also possible for a single intent to have multiple entities \cite{buiildChatbotsPython}.
Example sentence seven of Table \ref{tab:example_sentences} contains multiple entities.
In sentence seven of Table \ref{tab:example_sentences} one entity is the color of the shirt, 
a second one the shirt as an item and the third one the size.
Sentences three to six of Table \ref{tab:example_sentences} show entities in a book hotel example.
There are also named entities.
Named-Entity-Recognition (NER) is used to extract groups of information in a context from natural language.
NER is a sub-area of NLU.
Entity recognition also deals with ambiguity because the word May can mean different things in different contexts.
In sentence five May is the month whereas in sentence six of Table \ref{tab:example_sentences} it's a last name. 
A named entity is a noun phrase relating to individuals like organizations or geopolitical entities \cite{singhbuilding}.
The classic examples for named entities are people, locations, and organizations \cite{geyer2016named}.
Classic examples for named entities are the date-times of example sentences four and five,
and person names like in example sentence six of Table \ref{tab:example_sentences}.
These named entites are sometimes provided by the frameworks.
A developer can define named entities for a specific domain.
A custom entity can be a list of hotels like the "Twelve Months" 
hotel in sentence three of Table \ref{tab:example_sentences}.
An example entity for food items like apples and peas is shown in Figure \ref{fig:entityexampledialog}.
Entities are stored in the session and form the context of a conversation \cite{singhbuilding}.
They are only valid for the current conversation.
\makefigure{entityexampledialog}{Food Entity Example with Dialogflow}


\section{Chatbot Response} \label{sec:chatbot_response}
The response message of a chatbot is picked from a pool of utterances as described in \ref{sec:utterance}.
The response can be picked at random or in a sequence.
Dialogflow for example picks the response message at random.
Alterantives are picked to keep the conversation interesting for the users especially
if they are using the bot more than once.
The alternatives prevent a robot like feel in the conversation. 
If the same response is picked all the time users realize fast that they are 
talking to a bot system and it also gets boring fast. 
An exemplary list of responses for the default welcome intent of Dialogflow is shown in Figure \ref{fig:defaultwelcomeresponsedialogflow}.

\makefigure{defaultwelcomeresponsedialogflow}{Response List of the Default Welcome Intent of Dialogflow}




% regex image

\section{Story}
A story defines the dialog flow. 
It is a script for a conversation between man and machine.
The bot and the user interact in turns using natural language \cite{evaluateChatbotsShawar2007, shawar2007chatbots, huang2007extracting, gregori2017evaluation}.
Stories need to consider happy and sad paths. 
A happy path is a successful interaction from start to finish.
A sad path is everything else. Aborting a transaction is a classic sad path for instance. 
In Figure \ref{fig:greetstory} a story for a greeting sequence with a user is shown. 
The user starts the conversation by entering a greeting phrase. 
The response of the chatbot is also a greeting phrase and then the conversation ends in this case. 
An example conversation from a person with a chatbot is shown in Figure \ref{fig:faqexamplecrop}.
% story image from rasa-x
\makefigure{faqexamplecrop}{Example FAQ Conversation with Dialogflow}
\makefigure{greetstory}{Greeting Story}

% \section{NLU}
% The goal of NLU is to extract structured, semantic data from unstructured natural language input like
%  chat messages \cite{braunEvaluatingNLU}.
% To achieve this task the message or parts of the message are labeled \cite{braunEvaluatingNLU}.
\section{Webhook} \label{sec:webhook}
A webhook is a URL where the frameworks send metadata and intent data for analysis, completion, and processing.
In the case of this thesis, the webhook is a simple Pyhton REST service implemented with Flask.
Each framework gets a route in the service which is "/watson/webhook" for the Watson Assistant requests for example.
In Listing \ref{lst:webhookExample} an exemplary JSON request from Dialogflow is shown for the default welcome intent.
In the case of Dialogflow the incoming message can be found under query text, the response message under fulfillment text and the confidence under intent detection confidence. 
\begin{lstlisting}[caption={Dialogflow Webhook Request Example}, label={lst:webhookExample},captionpos=b,frame=single,language={[Sharp]C},commentstyle=\color{mygreen},keywordstyle=\color{blue},
morekeywords={}]                
[
{
    "originalDetectIntentRequest": {
        "payload": {}
    },
    "queryResult": {
        "action": "input.welcome",
        "allRequiredParamsPresent": true,
        "fulfillmentMessages": [
        {
            "text": {
                "text": [
                "Good day! What can I do for you today?"
                ]
            }
        }
        ],
        "fulfillmentText": "Good day! What can I do for you today?",
        "intent": {
            "displayName": "Default Welcome Intent",
            "name": "projects/onlineeatsbot-pxcmic/agent/intents/cc103476-1771-4b0e-bf86-c5d63af2e9ab"
        },
        "intentDetectionConfidence": 0.72385716,
        "languageCode": "en",
        "outputContexts": [
        {
            "name": "projects/onlineeatsbot-pxcmic/agent/sessions/c85918b3-c794-6d73-3c86-149ca19ea5a9/contexts/__system_counters__",
            "parameters": {
                "no-input": 0.0,
                "no-match": 0.0
            }
        }
        ],
        "parameters": {},
        "queryText": "Hi, how are you doing"
    },
    "responseId": "0686a282-abb6-4d24-abbd-bef3c38615ef-19db3199",
    "session": "projects/onlineeatsbot-pxcmic/agent/sessions/c85918b3-c794-6d73-3c86-149ca19ea5a9"
}
]\end{lstlisting}  

\section{Natural Language Processing/Understanding}   
The term "natural language" means input is received through voice or writing in the user's language of choice \cite{buiildChatbotsPython}.
Natural language processing in the area of chatbots is necessary to analyze the text input 
provided by the user and figure out the intent and entities necessary to process the given information \cite{buiildChatbotsPython}. 
Natural language processing is seen as the brain of a chatbot since it receives the information 
from the user, processes the data and retrieves the relevant parts from the input for post-processing \cite{buiildChatbotsPython}.
Part-of-Speech (POS) tagging is a process where parts of
speech like noun, verb, and adjective are assigned to each word/token \cite{buiildChatbotsPython}.
This information is used to understand the context and is part of NLU.
% Lemmatization and Stemming
An important part of natural language processing is the search for the root of words which can be done with 
stemming and lemmatization \cite{buiildChatbotsPython}.
Stemming reduces a word to the base form e.g. "saying" is reduced to "say" by removing the endings of words \cite{buiildChatbotsPython}.
Lemmatization tries to return the dictionary form of a word and has better correctness and is more
 productive than stemming and hence the preferred method \cite{buiildChatbotsPython}. 
 Lemmatization uses a vocabulary and morphological analysis of words to achieve its task \cite{buiildChatbotsPython}.
% stop words
Stop words are words that hold little to no meaning and occur in a high frequency like "the" and "a" which 
are removed.




