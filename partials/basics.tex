\section{Chatbot} \label{sec:chatbot}
A chatbot is a conversatinal agent able to communicate with a user using natural language 
\cite{evaluateChatbotsShawar2007, shawar2007chatbots, huang2007extracting, gregori2017evaluation}.
The term chatbot is a combination of the words chatting and robot.
In literature synonyms like chatterbot and conversational agent are used.
The communication with a chatbot is most often done in written form like in a chat but not restricted to it since 
speech is also classified as natural language.
The communication between man and machine is done in turns until a conversation end is reached 
or the conversation is aborted \cite{vrajitoru2004evolutionary}.
A conversation end is when the underlying tasks has been achieved.
The user input is interpreted by the chatbot and the most likely response is generated \cite{dutta2017developing}.
In the best case the generated response is reasonable and intelligent \cite{vrajitoru2004evolutionary}. 
In the worst case a generic message like "I didn't understand that" is generated.
It's important to keep in mind that a chatbot is able to mimic intelligence, human dialog, 
and personality but is often limited to specific functionality \cite{kane2016role, dutta2017developing}.

Three major chatbot types are present in literature.
There are menu-driven chatbots (\citet{singhbuilding}), domain-specific/goal-oriented/task-oriented chatbots (\citet{deshpande2017survey, luis2015williams, braunEvaluatingNLU, williams2017hybrid}),
and chatbots for general/open-ended/end-to-end conversations (\citet{brandtzaeg2018chatbots, singhbuilding}).
Menu-driven chatbots mimic a classical interface and navigate the user through the 
interface using text or speech.
An example for a menu-dirven chatbot is a phone call at a support hotline.
The caller is guided through the interface by the system and isn't connected to a person immediately.
The system gives options like "press one if you'd like to request a refund, press two 
if you need replacement parts", navigates the caller through the process, collects information like the order number, and 
connects the user to the correct department.
Domain-specific chatbots offer functionality which is limited to a domain.
Such systems provide the functionality to achieve specific tasks and are not supposed to handle anything else.
One example would be a refund desk in a shop.
If the customer asks for refund specific information or wants to issue a refund the customer is served.
If the customer asks where the TVs are located in the shop he is redirected to the information counter.
A chatbot system in the refund desk domain offers only the functionalty necessary to get and collect refund information, 
and to issue a refund. If the bot is asked something else no useful response can be expected.
Open-ended systems are made for a general conversation.
Contrary to the other two approaches the user can ask open-ended systems anything and the most likely response is generated.
There are no fixed rules what users may or may not ask and the conversation can develop in any direction.
These systems have a hard time to collect specific information since there is no way to tell which information is needed.
Every conversation can vary greatly hence no information can be presumed.
Popular examples for open-ended systems are Google Home, Siri (Apple), and Alexa (Amazon) \cite{singhbuilding}.
The most limited approach is the menu-drive approach since the options are given and a user only inputs numbers to select a functionality.
Domain-specific bots communicate with users in natural language and are good in achieving tasks and collecting information.
Open-ended systems are perfect for general communication and are not restricted to a domain but it's hard to collect specific information
or achieve a domain-specific task with such systems. General tasks are not a problem for open-ended systems.
A simple exemplary chatbot conversation is shown in Figure \ref{fig:faqexamplecrop}.

In general, a ML based chatbot system consists of rules and training data.
The training data is used to train the natural language capabilities and 
should be as realistic as possible.
The training data can be handcrafted for prototyping or generated from large sources like emails, phone calls,
or the internet.
The rules define the available functionality, types, and possible input statements.
One simple rule could be that a person name is required as input and consist of a first and last name.


\section{Chatbot/NLU Frameworks}
Many chatbot and NLU frameworks were created to enable non ML experts to 
develop chatbot systems.
The frameworks can be devided in cloud-based and local solutions.
The cloud based solutions are created, edited, and developed through a web-interface 
and are used in applications via a REST API endpoint.
The developer is dependent on the provider and the training and analysis is done 
in the coud of the provider. This needs to be kept in mind when dealing with
 sensitive information like bank accounts.
The big cloud providers offer chatbot or NLU frameworks in their cloud environment.
Microsoft has LUIS (\citet{luis2015williams, luisdocs}),
Google develops Dialogflow (\citet{dialogflow}),
IBM offers Watson Assistant (\citet{watsonassistant}),
Amazon provides Lex and Alexa.
The local solutions are standalone applications running on the development machine or 
the company server.
The data is never passed to another computer or the cloud since it runs local.
A popular local open-source solution is Rasa (\citet{rasabocklisch2017,rasa}). 
All the frameworks listed above use slot-filling.
A slot is a predefined type/entity which a user needs to enter in a conversation.
In Table \ref{tab:example_sentences} the slots which need to be filled for a hotel 
reservation could be the hotel name, start and end date, and a name for the 
reservation.
All of these slots need to be filled before the system can process the hotel 
reservation automatically.


\section{Suitable Problems for Chatbots} 
Chatbots seem like intelligent systems but most often they are design for specific tasks
and are unable to solve complex problems \cite{buiildChatbotsPython}.
Therefore, not every problem can be solved using chatbots \cite{buiildChatbotsPython}.
A problem can be solved effectively with chatbots when it is highly repetitive, can be automated, and 
can be done with simple back-and-forth communication.
A chatbot systems is meant to reduce the workload of employees or serve a large amount of users.
Therefore, the problem needs to be repetitive to fulfill these requirements.
It is possible to solve non repetitive tasks with chatbots too but it is not cost-effective.
The problem needs to be automated to simplify the process.
If it can't be automated an employee is needed for the process and it's harder to 
serve a large number of users.
Chatbots are based on natural language communication with text messages or voice.
Hence, the problem must fit in the back-and-forth communication pattern since there are no 
other means of communication available for chatbots.
If all the statements above can be answered with true the problem is suitable for a chatbot. 
A simple QnA bot for a FAQ page of a website is an example of a suitable problem \cite{buiildChatbotsPython}.
The task can be automated, is highly repetitive, and the answers are predefined by the FAQ page.

As mentioned in Section \ref{sec:chatbot} there are three major types of chatbots.
The menu-driven and domain-specific approach are suitable for tasks with a goal where data needs to
be collected to execute an action where only a limited set of functions needs to be supported. 
When the user can select an option from a limited list of actions the menu-driven approach works best
(support, helpdesk chatbot).
When users should be able to communicate using natural language to ask questions related to a
domain then the domain-specific approach works best (FAQ chatbot). In the FAQ example the domain 
consists of all questions and answers of the FAQ page.
It would be bothersome to navigate through a FAQ forum using numbers because if e.g. 1000 topics
are available the user would need to enter a number between one and 1000 and also would need to 
know the correct number for the question.
This would be horrible to use and no one would want to use such a system.
A user just wants to ask a question to get an appropriate answer.
This works best with natural language hence, the domain-specific approach is suitable.
The open-ended approach is suitable when no specific data needs to be collected and a general 
conversation needs to be held with the users. 
The Google Assistant can answer general questions like "What's the weather in New York" and 
gives a general response.
The Google Assistant can't process a request like 
"Tell my employee I am sick and won't come to work today" since this would require domain specific 
data and actions.



\section{Intent} \label{sec:intent}
Intents are the core concept of any chatbot system.
An intent is the action a user wants to perform \cite{dutta2017developing, rahman2017programming}.
In example sentence two in Table \ref{tab:example_sentences} the user wants to book a hotel.
The action the user wants to perform is "book a hotel".
The intent can be named "book hotel" for instance.
In general, the user queries the system, the system identifies the best matching intent, 
collects relevant information, and generates a response.
The identification of these intents is the core function of chatbots.
To identify the intent the system finds the intent where the training phrases are closest to 
the users query or uses the fallback if no intent reached a high enough score.
The score is represented by a percent value between zero and one.
One means a perfect match and zero is treated as absolutely no match.
A threshhold defines the minimum score the system has to detect before an action is executed.
All values below the threshhold are handeled by the fallback action e.g. a generic response like 
"I'm sorry but I didn't understand that".
In Table \ref{tab:example_sentences} example sentences are listed with their intent, and their entities.
In example sentence one of Table \ref{tab:example_sentences} the intent can be labeled as 
"Greet" since the user greets the bot.
Table \ref{tab:defaultwelcomedialogflow} shows a small excerpt of the information generated for
the default welcome intent created by Dialogflow.
The intent consists of training phrases and a response list.
The training phrases are used to train the ML model.
Everything which is similar to the training phrases and reaches the highest score 
will be classified as the intent.
The system then response with a random pick from the response list.
The random pick fakes intelligence since it would be boring for 
users to get the same response every time.
If the same response is returned all the time users would rate the communication as robotic 
but the goal is to make the conversation as natural as possible.

\begin{table}[H]
    \centering
    \begin{tabular}{ l | c | c | l }
  No. & Intent & Type & Sentences \\ \hline \hline
  \multirow{8}{*}{1}
  & \multirow{8}{*}{Default Welcome} & \multirow{8}{*}{Training Phrases} & hey \\
      & & & howdy partner\\
      & & & heya\\ 
      & & & hello hi\\ 
      & & & hey there\\ 
      & & & hi there\\ 
      & & & greetings\\ 
      & & & howdy \\ \hline
  \multirow{4}{*}{2}
  & \multirow{4}{*}{Default Welcome} & \multirow{4}{*}{Response List} & Hi! How are you doing? \\
      & & & Hello! How can I help you?\\
      & & & Good Day! What can I do for you today?\\ 
      & & & Greetings! How can I assist?\\ \hline
\end{tabular}
    \caption{Default Welcome Intent of Dialogflow} \label{tab:defaultwelcomedialogflow}
\end{table} \noindent



\section{Utterance} \label{sec:utterance}
An utterance is a sentence or a part of a sentece.
Especially in the area of chatbots an utterance is often a part of a sentence since 
chat messages are often shortened. 
All sentences listed in Table \ref{tab:example_sentences} are utterances for instance.
The messages of users are utterances \cite{singhbuilding, dutta2017developing}.
The chatbot also responds to users with utterances.
Table \ref{tab:defaultwelcomedialogflow} shows some training phrases and the response list.
The sentences listed as training phrases and response list are utterances. 
Table \ref{tab:defaultwelcomedialogflow} shows that a collection of utterances
belongs to an intent and builds the base for the classification of user input.
The training phrases are different versions of the same question or statement.
The different versions allow the system to correctly classify utterances which
never were part of the training data as long as the utterance is similar.
Example sentence two of Table \ref{tab:example_sentences} can be used 
as utterance for the book hotel intent.
Utterances need to be chosen with care to prevent overfitting to unimportant 
features of the sentences.
If all utterances contain a specific word at a specific position the model 
might learn that a specific word must be at that position all the time.
Utterances for training purposes can come from multiple sources.
They can be handcrafted for development and testing.
The data can come from live systems.
Real user input from e.g. e-mails, phone conversations, or online resources can be used to get a
 large amount of training data \cite{singhbuilding}.    


\begin{table}[H]
    \centering
    \begin{tabular}{ c | l | c | l }
        No. & Sentence & Intent & Entities \\ \hline \hline
        1 & Hello & Greet & - \\ \hline
        2 & I'd like to book a hotel & Book Hotel & - \\ \hline
        3 & The Twelve Months hotel & - & Hotel Item\\ \hline
        4 & From the 27th of April & - & Date (From)\\ \hline
        5 & To the 4th of May & - & Date (To)\\ \hline
        6 & Ethan May & - & Person (Name)\\ \hline
        7 & Order one green t-shirt size M please & Place Order & T-Shirt Item, Color, Size \\ \hline
    \end{tabular}
    \caption{Examples for Concept Explanation} \label{tab:example_sentences}
\end{table} \noindent

\section{Entity} \label{sec:entity}
An entity is a piece of information which needs to be extracted from natural language.
An entity is metadata which belongs to an intent an has a type.
Entities can be represented as volumes, counts, and quantities for instance \cite{buiildChatbotsPython}.
An intent can have multiple entities like in example sentence seven of Table 
\ref{tab:example_sentences}.
In sentence seven one entity is the color of the shirt, 
a second one the shirt as an item, and the third one the size.
Sentences three to six of Table \ref{tab:example_sentences} show entities in a book hotel example.
In a simplified example, to book a hotel the name of the hotel (Hotel Item), 
the check-in and check-out dates (Date), 
and a name (Person) are needed for the reservation.
To extract entities in a context from natural language Named-Entity-Recognition (NER) is used.
NER is a sub-area of NLU.
Entity recognition deals with word ambiguity.
Sentences five and six show a word ambiguity.
In sentece five May is the month and needs to be trated as a date whereas in sentence six of Table \ref{tab:example_sentences} 
it's a last name and needs to be treated as a person entity. 
A named entity is a noun phrase relating to individuals.
Classic individuals/named entites are person (Bill Gates), location (New York), and organization (Google) \cite{geyer2016named}.
Frameworks sometimes provide predefined named-entities like the ones above which are needed
on a regualar basis.
A developer can define named entities for a specific domain like in the hotel example where an 
entity is needed which knows all valid hotel names.
Example sentences four and five of Table \ref{tab:example_sentences} show a date entity,
and example sentence six shows a person entity.
An example entity for food items like apples and peas is shown in Table \ref{tab:entityexampledialog}.
An entity can be a collection of items like for the fruits but it can also be a collection of synonyms.
Entities are stored in the session and form the context of a conversation \cite{singhbuilding}.
They are only valid for the current conversation.

\begin{table}[H]
    \centering
    \begin{tabular}{ c | c | l | l }
  No. & Entity & Item & Synonyms \\ \hline \hline
  \multirow{4}{*}{1} & \multirow{4}{*}{Fruit Item} & apple & apples \\
       & & banana & bananas\\
       & & pea & peas \\ 
       & & peach & peaches \\ \hline
    2 & Sick Item & sick & ill, unwell, poorly, indisposed, sickly, ailing \\
    \hline
\end{tabular}
    \caption{Entity examples} \label{tab:entityexampledialog}
\end{table} \noindent


\section{Chatbot Response} \label{sec:chatbot_response}
The response message of a chatbot is picked from a pool of utterances as described in \ref{sec:utterance}.
The response can be picked at random or in a sequence.
Alterantives are picked to keep the conversation interesting for the users especially
if they are using the bot more than once.
The alternatives prevent a robot like feel in the conversation. 
If the same response is picked all the time users realize fast that they are 
talking to a bot system and it gets boring fast. 
An exemplary list of responses for the default welcome intent of Dialogflow is shown 
in Table \ref{tab:defaultwelcomedialogflow} next to response list.


% regex image

\section{Story}
A story defines the dialog flow. 
It's a step-by-step script for a conversation between man and machine.
The bot and the user interact in turns using natural language \cite{evaluateChatbotsShawar2007, shawar2007chatbots, huang2007extracting, gregori2017evaluation}.
The user ask a question or makes a statement and the bot processes the request and delivers a response.
A story can be a "happy" or "sad" path.
A "happy" path is a successful interaction from start to finish without any problems.
The "sad" path handles the behaviour when something doesn't work out.
It could be that the user input is wrong and needs to be reentered when the validation fails.
The user can also quit the conversation at any time.
These "sad" paths need to be handeled in separate stories.
In Figure \ref{fig:greetstory} a story for a greeting sequence with a user is shown. 
The user starts the conversation by entering a greeting phrase. 
The response of the chatbot is also a greeting phrase and then the conversation ends. 
An example conversation from a person with a chatbot is shown in Figure \ref{fig:faqexamplecrop}.
The story for \ref{fig:faqexamplecrop} is that the user asks for open hours, the bot respond open hours, 
the user asks for an item, the system validates the item and a response is generated with 
the item in the response text.

\makefigure{faqexamplecrop}{Example FAQ Conversation with Dialogflow}
\makefigure{greetstory}{Greeting Story}

% \section{NLU}
% The goal of NLU is to extract structured, semantic data from unstructured natural language input like
%  chat messages \cite{braunEvaluatingNLU}.
% To achieve this task the message or parts of the message are labeled \cite{braunEvaluatingNLU}.
\section{Webhook} \label{sec:webhook}
A webhook is a URL where the frameworks send metadata and intent data for analysis, completion, and processing.
In the case of this thesis, the webhook is a simple Pyhton REST service implemented with Flask.
Each framework gets a route in the service which is "/watson/webhook" for the Watson Assistant requests for example.
In Listing \ref{lst:webhookExample} a simplified JSON request from Dialogflow is shown for the default welcome intent.
In the case of Dialogflow the incoming message can be found under query text, the response message under fulfillment text and the confidence under intent detection confidence. 
\begin{lstlisting}[caption={Dialogflow Webhook Request Example}, label={lst:webhookExample},captionpos=b,frame=single,language={[Sharp]C},commentstyle=\color{mygreen},keywordstyle=\color{blue},
morekeywords={}]                
[
{
    "originalDetectIntentRequest": {
        "payload": {}
    },
    "queryResult": {
        "action": "input.welcome",
        "allRequiredParamsPresent": true,
        "fulfillmentMessages": [
        {
            "text": {
                "text": [
                "Good day! What can I do for you today?"
                ]
            }
        }
        ],
        "fulfillmentText": "Good day! What can I do for you today?",
        "intent": {
            "displayName": "Default Welcome Intent"
        },
        "intentDetectionConfidence": 0.72385716,
        "languageCode": "en",
        "parameters": {},
        "queryText": "Hi, how are you doing"
    },
}
]\end{lstlisting}  


\section{Domain}
The domain of a chatbot is equal to the functionality.
A domain-specific chatbot has a limited set of operations and works with data relevant to the domain.
If the chatbot is built for a refund-desk scenario then the domain is refund for example.
The bot can process and answer refund related issues, collects refund specific information,
and can issue a refund. It doesn't offer functionality which is unrelated to the refund domain like 
"What's the weather in New York today" and it is not supposed to do so.
Open-ended systems escape the domain limitation but have problems to execute domain-specific tasks
or collect domain-specific information. 

\section{Evaluation of NLP capabilities}
The scenario for this explanation is a medical test for a disease.
Positive is treated as the person has the disease.
A true positive (tp) is when the test is positive and the person has the disease.
A false positive (fp) is when the test is positive but the person is healthy.
A true negative (tn) is when the test is negative and the person is healthy.
A false negative (tn) is when the test is negative but the person has the disease.
In the area of chatbots a true positive is when the input is e.g. "Hello" and the identified 
intent is "Greet Intent".
The precision is calculated as $\frac{tp}{tp + fp}$.
The recall is calculated as $\frac{tp}{tp + fn}$.
The f-score is calculated as $2 * \frac{precision * recall}{precision + recall}$.

\section{Natural Language Processing/Understanding}   
The term "natural language" means input is received through voice or writing in the user's language of choice \cite{buiildChatbotsPython}.
Natural language processing in the area of chatbots is necessary to analyze the text input 
provided by the user and figure out the intent and entities necessary to process the given information \cite{buiildChatbotsPython}. 
Natural language processing is seen as the brain of a chatbot since it receives the information 
from the user, processes the data and retrieves the relevant parts from the input for post-processing \cite{buiildChatbotsPython}.
Part-of-Speech (POS) tagging is a process where parts of
speech like noun, verb, and adjective are assigned to each word/token \cite{buiildChatbotsPython}.
This information is used to understand the context and is part of NLU.
% Lemmatization and Stemming
An important part of natural language processing is the search for the root of words which can be done with 
stemming and lemmatization \cite{buiildChatbotsPython}.
Stemming reduces a word to the base form e.g. "saying" is reduced to "say" by removing the endings of words \cite{buiildChatbotsPython}.
Lemmatization tries to return the dictionary form of a word and has better correctness and is more
 productive than stemming and hence the preferred method \cite{buiildChatbotsPython}. 
 Lemmatization uses a vocabulary and morphological analysis of words to achieve its task \cite{buiildChatbotsPython}.
% stop words
Stop words are words that hold little to no meaning and occur in a high frequency like "the" and "a" which 
are removed.




