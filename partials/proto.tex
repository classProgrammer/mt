\section{Dialogflow}
Dialogflow\cite{dialogflow}, formerly known as API.ai, is the chatbot framework of Google and is hosted in the Google cloud.
The input language and a name for the agent are required to create a new agent.
The selected language is the interaction language of the users, not the development language.
Dialogflow offers the option to create a mega agent by combining multiple agents.
Figure \ref{fig:dialogflow_interface} shows the web interface with the menu entries titled intents and entities.
Dialogflow uses the basic concepts of intents, entities, and utterances.
The implementation uses the intents, entities, and utterances listed in Table \ref{tab:conversation_data}.

\subsection{Intents and Entities}
An intent in Dialogflow has training phrases, actions, parameters,
a response list, a context, and the fulfillment.
As described in the basics, the training phrases are a list of utterances a user would enter and belongs to an intent.
The parameters are the slots to fill in a conversation and have an entity as type.
The parameters for the sickness intent are the rows of Table \ref{tab:example_sentences}, for instance.
The response list is a list of utterances used to respond to the user's question at the end of an intent.
The context passes parameters from one intent to the next.

By default, an intent is handled by Dialogflow without communication to another service.
The use-cases require communication with an external service for data processing.
The fulfillment section offers the concept of webhooks for this reason.
When enabled, the webhook can handle all kinds of requests like entity extraction or processing of the extracted information after the form-data collection.
For the sickness notification use-case, the webhook processes the name of a person, and an optional return date after the chatbot collected the data.
The webhook functionality covers all data submission requirements for the use-cases.

Dialogflow provides many predefined entities and intents.
Dialogflow predefines the date and person entities, and it is not necessary to create them.
Additionally, yes and no intents are also available and can be used and 
adjusted for the current sickness notification use case.
With the concept of follow-up intents, the structuring of intents is possible.
One or multiple intents can follow after an intent, hence the name.
The final structure is a sickness intent which is followed by either 
the yes or the no intent.
At the end of the no intent, the chatbot responds with a retry response.
At the end of the yes intent, the bot responds with an all done response.
Both conversation paths end the conversation, which is related to data collection and processing.
They are optionally followed by thank you, goodbye, or chit-chat, but this is independent of data collection and storage. 

The process looks the same for the vacation use case.
The vacation intent needs to be created and has the follow-up intents 
yes, and no for the input confirmation.
The entities required are person and date-span.
Dialogflow offers two predefined entities for date-span handling.
The first entity is called date-period, and the second one is called date-time.
The advanced features of these entities show why predefined entities are better than custom entities for standard problems.
Both date entities parse dates like 06.27.2020 correctly.
They are also capable of processing weekdays (Monday) and periods like Monday to Friday and tomorrow correctly.
It is possible to implement such behavior for a custom entity but is additional work
They also convert dates to the correct values.
If Monday is in the past for the span Monday to Friday, the resulting date period will be from the future Monday to Friday after next Monday.
The provided standard functionality for dates and date-spans is very convenient and user friendly.

When the slots are part of the training sentences, experienced users can shorten the workflow.
Usually, the user enters the required information slot by slot.
The user is not queried for a slot when the information is already present.
With these concepts, sending all the information with the first request is possible.
This speeds up the process for experienced users.
In a sentence like "Max Power is sick and will return Monday" all the required information is present, and the request can be processed immediately.
 

In general, custom entities are a list of entries or a list of entries with synonyms.
An advanced feature of Dialogflow is small-talk.
It can be enabled in the settings with a single click.
When small-talk is enabled, the bot responds to requests like "What are you", "Bye", and "sorry".
This is another useful feature of Dialogflow, which is predefined and requires no development effort. 

\subsection{Webhook}
The Dialogflow webhook requires an HTTP POST URL as an entry point.
The communication relies on JSON as a format.
Listing \ref{lst:dialogflow_entry_point} shows the entry point of the webhook.
A request (Listing \ref{lst:webhookExample}) can be accessed like a dictionary or an array shown in Listing \ref{lst:dialogflow_request_params} where the name of the intent gets extracted. 
After the intent has been extracted, the parameters are extracted to process the request.
In the error case, a new fulfillment message is returned.
A fulfillment message as return value prevents follow up intents.
In the success case, an empty response is returned, and the bot continues normally.
Listing \ref{lst:dialogflow_intent_handling} shoes a skeleton for intent handling for the success and error scenario of an intent called "Sickness Confirmed".

\begin{lstlisting}[caption={Dialogflow Webhook Entry Point}, label={lst:dialogflow_entry_point},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
@restService.route('/dialogflow/webhook', methods=['POST'])
def dialogflowRequestEntryPoint():
    return asJsonResponse(dialogflowRequestHandler()), 200
\end{lstlisting}  

\begin{lstlisting}[caption={Dialogflow Request Parameters}, label={lst:dialogflow_request_params},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
req = request.get_json(force=True)
intent = req.get('queryResult').get('intent').get('displayName')
\end{lstlisting}  

\begin{lstlisting}[caption={Dialogflow Intent Handling}, label={lst:dialogflow_intent_handling},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
if intent == 'Sickness Confirmed':
 params = req.get('queryResult').get('outputContexts')[0].get('parameters')
 employee_name = params.get('employee').get('name').lower()
 return_date = params.get('return_date')
 if !employeeExists(employee_name):
  return {
    "fulfillmentMessages": [
      {"text": {"text": ["Employee not found. Enter sick to retry."]}}
    ]
  } # RETURN ERROR MESSAGE
  else:
   db.store_sickness(employee_name, return_date) # PROCESS DATA
   return {} # CONTINUE NORMALLY
elif intent == 'Vacation':
    ...
\end{lstlisting}  
\makefigure{dialogflow_interface}{Dialogflow Web Interface}

% ----------------------------------------------------
% ---------------------- WATSON ----------------------
% ----------------------------------------------------
\section{Watson Assistant}
Watson Assistant\citet{watsonassistant} is the cloud chatbot technology of IBM hosted in the IBM cloud.
An IBM cloud account is required to use the services.
First, a new assistant needs to be created, which requires a name.
Then dialog skills can be created.
Figure \ref{fig:watson_interface} shows the web interface of Watson Assistant.
The interface offers the concepts of intent, entity, and dialog.
A dialog node represents the actions when an intent is recognized.
The structuring of dialogs works the same way as with Dialogflow.

\subsection{Intents and Entities}
The required entities are person and date.
Watson Assistant offers system entities for persons and dates.
Watson uses the same concept as Dialogflow for communication with external services.
After entering a webhook URL in settings, the endpoint can be used in the application.

The person entity is marked deprecated and is available in English but not in German.
It is possible to create new entities by using examples or regular expressions.
IBM recommends the creation of a custom person entity with entity annotations in the test sentences to eliminate the deprecated person entity.
Every occurrence of person names in the test sentences needs to be highlighted and marked (annotated) as a person entity.
The sickness use-case requires a new intent. 
Then the training phrases are added to the intent.

A condition triggers a dialog node.
For the sickness use-case, the dialog node triggers every time the bot recognizes a sickness intent.
The settings menu of a dialog node offers customization options.
Customization options are slot filling and calling a webhook, for instance.
The sickness-notification use-case requires both options.
The required slots for the form filling are a person of type person and the return date of type date.
The person is mandatory, and the date is optional.
The webhook receives a request at the defined URL after the form-data collection.

\subsection{Dialog and Webhook}
The format of the webhook call is JSON.
The parameters need to be specified by hand.
The required parameters are the name of the intent, the person name, and the return date.
The name of the intent is necessary to execute the correct action at the webhook.
The name and the return date are the information stored in the backend for a successful request.
Listing \ref{lst:watson_request} shows that the requests of Watson Assistant contain no meta-information by default.
The developer defines the information and format submitted to the webhook.
The webhook returns a JSON object.
A context variable stores the JSON object.
It is accessible in the chatbot code like a regular struct in C++.

Based on the webhook response, the dialog can go in different ways.
It is possible to define a response for each possible response.
If the request only contained the name of a person, only the name of the person is present in the response message.
If the request contained a name and a date, both are present in the chatbots response message.
Whenever the webhook finds a person in the backend, the user needs to confirm that the entered information is correct.
If the person was not found the retry message is displayed
Watson Assistant offers conditional statements to handle such cases.

Table \ref{tab:watson_cond_response} shows the conditions, responses, and actions of the use case.
Chatbot responses can be picked sequentially, at random, or as a multiline response.
The multiline response displays all response lines at once.
The sequential version picks them in order, and the random variant picks the response at random from the available responses.
The confirmation logic is the next thing to implement.
No system entity or dialog for the confirmation logic is present.
Two intents or an entity are options to represent the confirmation.
An entity with two possible values (true, false) is a logical and straightforward approach.
The entity is called confirmation.
For these two cases, synonyms are defined like confirm, yes, and OK for true.
When the entity is detected, the correct path is selected based on the value.
The webhook response shown in Table \ref{tab:watson_cond_response} used similar logic.
The confirm or abort logic requires an additional dialog node.
The jump option in the settings of the dialog node allows a dialog node to be triggered based on the value of the variable.
For the confirm or abort dialog requires form-data and a webhook call after the confirmation.
Both options were enabled in the setting menu, like for the other nodes.
When the user aborts the operation, the webhook is not called.
The confirmation slot is of type confirmation entity and is required.
The webhook receives a request with the collected information.
If everything went fine, an all done message is displayed.
If something went wrong, an error message is displayed instead.
This ends the sickness dialog.

The vacation use-case is quite similar in structure.
The vacation use-case requires a date-span entity.
Watson Assistant offers no date-span entities, but it is possible to use two separate dates instead.
It is impossible to create compound entities with Watson.
A compound entity cloud store two dates. 
The options are to create an intent with two dates in it or a dialog node 
which fetches the required dates as form-data.
This thesis uses the dialog node approach because it comes close to the 
behavior implemented with Dialogflow.
A new dialog node named vacation is created.
For the dialog node, an intent called vacation is created with 
the example sentences.
The dialog needs a mandatory person slot and two mandatory date slots.
The date slots are the start and return dates of the vacation.
After the information has been collected the information can optionally 
be validated through the webhook.
Then the user needs to confirm the information like in the sickness use-case.
The confirmation dialog works the same way for both use-cases.
Then the final request is sent to the webhook, which stores the collected information.
The final all done message is displayed, and the vacation use-case is implemented.

\begin{table}[H]
    \centering
    \begin{tabular}{ l | l | l  }
  Condition & Chatbot Response & Jump To Action \\ \hline \hline
  \$response.OK \&\& \$date!=null & Please confirm \$person is sick & \multirow{2}{*}{Confirm or abort} \\
        & until \$date. & \\ \hline
  \$response.OK & Please confirm \$person is sick. & Confirm or abort \\ \hline
  \multirow{2}{*}{\$response.ERROR} & \$person not found. Enter sick to & \multirow{2}{*}{Wait for input} \\ 
  &  retry. & \\ \hline

\end{tabular}
    \caption{Conditional Responses of Watson Assistant} \label{tab:watson_cond_response}
\end{table} \noindent


\begin{lstlisting}[caption={Watson Assistant Request Format}, label={lst:watson_request},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
[{
        "intent": "Sick",
        "person_name": "Anna Nass",
        "return_date": "2020-05-27"
}]
\end{lstlisting}  

\makefigure{watson_interface}{Watson Assistant Web Interface}

% ----------------------------------------------------
% ----------------------  RASA  ----------------------
% ----------------------------------------------------
\section{Rasa}
Rasa\cite{rasa} is an open-source framework for NLU and chatbot implementation.
Rasa runs inside a Docker container or in a local Python environment.
Rasa uses Python as a development language and can be installed using pip.
Listing \ref{lst:rasa_compose} shows a Docker compose file for Rasa, and the action server. 
Rasa offers a standalone NLU application, the action server, and chatbot development.

Rasa consists of two parts for chatbot development.
The natural language part takes care of everything related to 
the conversation like intents, entities, the story, and the conversation flow.
The second part handles the slot filling and other actions.
For each part, a Docker image can be created.

The Docker compose file of \ref{lst:rasa_compose} can be used similarly for the Azure deployment in combination with the images.
Azure also offers a Docker registry to upload and pull custom images.
It is important to choose a compatible version of rasa and rasa-SDK.
The Rasa image is responsible for the NLU part and the Rasa sdk runs the 
actions server.
\begin{lstlisting}[caption={Rasa Docker Compose File}, label={lst:rasa_compose},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
version: '3.0'
services:
    rasa:
    image: rasa/rasa:1.4.6
    ports:
        - 80:5005
    networks: 
        - app_net
    volumes:
        - ./:/app
    command:
        run 
        --enable-api
        --cors *
    
    action_server:
    image: rasa/rasa-sdk:1.4.0    
    volumes:
        - ./actions:/app/actions
    expose: 
        - 5055
    networks: 
        - app_net
networks: 
    app_net:
\end{lstlisting}  
The information for a Rasa chatbot is scattered across multiple files.
The nlu.md file stores the intents with the utterances used for training.
Listing \ref{lst:rasa_intent_format} shows the format for intents.
\begin{lstlisting}[caption={Rasa Intent Format}, label={lst:rasa_intent_format},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
## intent:sick
    - My colleague [Max Power](PERSON) is sick until [Friday](date)
    - somebody is sick 
    - a colleague is ill today
\end{lstlisting} 
The stories.md file stores the stories. 
A story defines the flow of the dialog from start to end.
Listing \ref{lst:rasa_story_format} shows the sickness story.
\begin{lstlisting}[caption={Rasa Story Format}, label={lst:rasa_story_format},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={sickness, submit, affirm}]                
## Sickness Affirm
* sickness
    - sickness_form
    - form{"name":"sickness_form"}
* submit{"PERSON":"Anna Maria Mayer"}
    - sickness_form
    - slot{"PERSON":"Anna Maria Mayer"}
* submit{"time":"2020-05-30T00:00:00.000-07:00","DATE":"today"}
    - sickness_form
    - form{"name":null}
    - slot{"time":"2020-05-30T00:00:00.000-07:00"}
* affirm
    - action_submit_sickness_data
    - action_restart
\end{lstlisting} 
The actions.py file defines all the actions which are callable in the chatbot files.
The sickness form slot filling is one action, for instance.
The domain.yml file lists all intents, entities, and actions.
If they are not listed in the domain.yml file, they cannot be used in the application.
The defined actions can be simple utterances or something complex like the slot filling of a form.
In utterance actions, the response is chosen at random from the list of responses.
In the endpoints.yml file, the action server needs to be entered to use the actions server for slot filling.
The actions server runs separately from the NLU service at the standard port 5055.
The NLU service is accessible at default port 5005.

Rasa offers great freedom when it comes to configuration.
This is important because Rasa does not offer predefined entities as such.
However, spacy does offer the required date and person entities for the use cases.
Duckling is another option for data and date-span extraction.
In the config file shown in Listing \ref{lst:rasa_config}, the pipeline includes the spacy entity extractor and Duckling to enable the use of predefined entities.
\citet{spacyapi} lists the entities supported by Spacy under named entity recognition.
The entity recognition of spacy does work, but the dates are stored as they are.
The best case is when the date is converted in a standard format like 
Dialogflow and Watson Assistant do.
To gain access to a more powerful date parsing the Duckling\cite{duckling} Rasa Docker image is used.
Duckling converts entered dates and times to a standard format as the cloud services do.
It recognizes strings like "Monday" as dates and converts them correctly.
Duckling works similar to the date and date-span entities of Watson Assistant and Dialogflow.
The person entity of Spacy works as expected.
The used entities need to be added under entities in the domain.yml file. If they are not listed in the domain.yml file, they cannot be used in the application.
People with machine learning experience can define custom pipelines or adjust parameters of components.
Listing \ref{lst:spacy_pipeline_detail} shows the detailed pipeline used for this thesis.

The config file defines policies.
The form policy enables the use of forms, and the fallback policy enables a fallback action, which is triggered when the confidence score is below the defined threshold. 
In the sickness use case, a generic utterance is the fallback response. 

\begin{lstlisting}[caption={Rasa Configuration}, label={lst:rasa_config},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={language, pipeline, policies, name}]                
language: en
pipeline: 
    - name: "SpacyNLP"
    - name: "SpacyTokenizer"
    - name: "SpacyFeaturizer"
    - name: "RegexFeaturizer"
    - name: "DucklingHTTPExtractor"
        url: "http://localhost:8000"
    - name: "SpacyEntityExtractor"
    - name: "EntitySynonymMapper"
    - name: "SklearnIntentClassifier"
policies:
    - name: MemoizationPolicy
    - name: TEDPolicy
    - name: MappingPolicy
    - name: FormPolicy
    - name: FallbackPolicy
    nlu_threshold: 0.4
    core_threshold: 0.3
    fallback_action_name: action_default_ask_rephrase
\end{lstlisting} 
The general command required to work with Rasa are train, shell, run actions, and x.
The command "rasa train" trains Rasa with the current data.
The shell command starts an interactive shell to test the bot.
The action server runs separately from the NLU service.
After the installation of Rasa-X, the command "rasa x" starts a web UI for the development of the chatbot.
Figure \ref{fig:rasa_x_interface} shows the UI of Rasa-X.
The web interface offers the files discussed in the training section (left) with additional features like the conversation graph (right) called flow for a story (middle) shown in Figure \ref{fig:rasa_x_interface}.

Rasa X offers interactive training, which allows developers to build chatbots through live interaction with the bot. 
Rasa stores a model every time it is trained.
This means the training history is available and old bots can be loaded.
If a feature does not work out, just load the old model.
\makefigure{rasa_x_interface}{Rasa X Interface}

For the sickness use-case, a new intent called sickness needs to be defined in the domain file.
The sickness intent needs slot filling, and the required entities are the 
person and the return date. 
The slots need to be defined in the slots section.
Every slot needs an utterance, which is named utter\_ask\_<SLOTNAME>.
The utterance is displayed when the bot asks for a slot.
Slot filling requires an action.
An example slot filling action is shown in Listing \ref{lst:slot_fill_action}.
The action needs the name function, which returns a unique name.
The required slots need to be defined.
The bot does not ask for unrequired slots.
The slot mappings function defines the type of the slots.
The submit function is called as soon as the slots have been filled.
In the submit function the collected information can be sent to the 
external endpoint, for instance.
Each slot allows the definition of custom validation rules.
This way, the validation of person names is possible at the action server.
Now the intent needs to be defined in the NLU file.
The sickness intent and the training phrases need to be defined in the 
NLU  file in the format shown in Listing \ref{lst:rasa_intent_format}.
Square brackets mark entities and parentheses mark the types.
Now the sickness story needs to be defined.
Phrases trigger the slot filling mechanism when the correct intent is recognized.
The next step is the confirmation dialog, where the user confirms the entered information.

A submit sickness data action is required.
The submit action requires the "affirm" and "deny" intents.
When the affirm intent is recognized, the confirmation action is triggered.
In the run method of the submit action, the data can be validated and processed.
The deny conversation path clears the slots and displays the retry message.
Listing\ref{lst:rasa_story_format} shows the affirm conversation path of the sickness use-case.
The vacation use case is not different from the sickness use-case in Rasa.

The Duckling time entity can process times, time-spans, dates, and date-spans.
For Duckling, there is no difference between a single date and a date-span.
Both are stored in the time slot and are of type time.
Both use-cases use the same slots and types.
There is absolutely no difference between the use-cases regarding the entities.
The response messages are different, however.

For the vacation use-case, a new intent needs to be added to the domain file.
The vacation training phrases need to be listed in the NLU file.
The vacation intent requires a form and a submit action.
The structure of the form and submit actions is the same as for the sickness use-case.
The actions need to be listed in the domain file to be usable in the stories.
The response messages and conditions are adjusted as needed.
Then the new stories need to be created.
With Rasa-X, the stories are created through live interaction with the bot.
The structure of the vacation story is the same as for the sickness story.



% ----------------------------------------------------
% ----------------------  LUIS  ----------------------
% ----------------------------------------------------
\section{LUIS}
With LUIS\cite{luisdocs}, the language understanding service of Microsoft, NLU services can be created.
NLU is only a part of a chatbot, and it is impossible to create a chatbot with LUIS alone.
The chatbot features are available through the Microsoft bot services 
in combination with LUIS.
A LUIS account is necessary to create NLU services.
A new NLU project requires a name for the service and an input language.
The chosen language is the language the users will use for communication with the LUIS application.
The build tab provides the interface to modify and build an NLU service with LUIS.
\makefigure{luis_interface}{LUIS Web Interface}
The interface shown in Figure \ref{fig:luis_interface} offers intents and entities like described in Chapter \ref{chap:basics}.
All four tested technologies have intents and entities and use utterances for training.
Marking of entities in training sentences is also possible with LUIS.

Table \ref{tab:conversation_data} and \ref{tab:conversation_data} list the required intents and entities.
Figure \ref{fig:conversationflow} does not influence LUIS because the 
conversation handling is not part of the NLU service.
Only a name and a list of training phrases (utterances) are necessary to create an intent with LUIS.

Multiple options are available to create different kinds of entities.
There are "simple" entities that describe a single concept like a city, for instance.
There are composite entities that combine multiple entities (parts).
A ticket with an id, event name, the price, and the number of tickets is an example of a composite entity.
For a list of valid entries, entity lists are the right choice.
In the book hotel example, a list of valid hotel names existed.
This list is a suitable example of entity lists since the number of valid entries is limited. 
Invalid hotel names are uninteresting in such a case.
Entity definition by a pattern is another possibility.
LUIS offers regular expressions\cite{regex} (regex) for the entity definition.
All four frameworks offer regex entities, and regex entities are, therefore, considered to be state-of-the-art.

It is also possible to add prebuilt entities and prebuilt domain entities.
The entities required for the sickness intent are person name and date. 
LUIS offers the prebuilt entities date-time and person-name.
LUIS defines all required entities as prebuilt entities, and there is no need to add custom entities for the use-cases.
The submit name and a submit return date intent allowed the testing of the entity quality.
The submit name intent extracts the person name entity.
The submit return date entity extracts a date-time entity.
The advantage of predefined entities is the saved time and the 
advanced features.
The date-time entity matches inputs like Monday or tomorrow and converts them to a valid and correct date by default.
The year is also automatically added when the date lies in the past.
Hence, the data-span entity parses vacation requests for the upcoming year correctly by default.
The required intents and entities were defined with LUIS for the performance comparison with the chatbot frameworks.
