\section{Dialogflow}
Dialogflow\cite{dialogflow}, formerly known as API.ai, is the chatbot framework of Google and is hosted in the Google cloud.
The input language and a name for the agent are required to create a new agent.
The selected language is the interaction language of the users, not the development language.
Dialogflow offers the option to create a mega agent by combining multiple agents.
Figure \ref{fig:dialogflow_interface} shows the web interface with the menu entries titled intents and entities.
Dialogflow uses the basic concepts of intents, entities, and utterances.
The implementation uses the intents, entities, and utterances listed in Table \ref{tab:conversation_data}.

\subsection{Intents and Entities}
An intent in Dialogflow has training phrases, actions, parameters,
a response list, a context, and the fulfillment.
As described in the basics, the training phrases are a list of utterances a user would enter and belongs to an intent.
The parameters are the slots to fill in a conversation and have an entity as type.
The parameters for the sickness intent are the rows of Table \ref{tab:example_sentences}, for instance.
The response list is a list of utterances used to respond to the user's question at the end of an intent.
The context passes parameters from one intent to the next.

By default, an intent is handled by Dialogflow without communication to another service.
The use-cases require communication with an external service for data processing.
The fulfillment section offers the concept of webhooks for this reason.
When enabled, the webhook can handle all kinds of requests like entity extraction or processing of the extracted information after the form-data collection.
For the sickness notification use-case, the webhook processes the name of a person, and an optional return date after the chatbot collected the data.
The webhook functionality covers all data submission requirements for the use-cases.

Dialogflow provides many predefined entities and intents.
Dialogflow predefines the date and person entities, and it is not necessary to create them.
Additionally, yes and no intents are also available and can be used and 
adjusted for the current sickness notification use case.
With the concept of follow-up intents, the structuring of intents is possible.
One or multiple intents can follow after an intent, hence the name.
The final structure is a sickness intent which is followed by either 
the yes or the no intent.
At the end of the no intent, the chatbot responds with a retry response.
At the end of the yes intent, the bot responds with an all done response.
Both conversation paths end the conversation, which is related to data collection and processing.
They are optionally followed by thank you, goodbye, or chit-chat, but this is independent of data collection and storage. 

The process looks the same for the vacation use case.
The vacation intent needs to be created and has the follow-up intents 
yes, and no for the input confirmation.
The entities required are person and date-span.
Dialogflow offers two predefined entities for date-span handling.
The first entity is called date-period, and the second one is called date-time.
The advanced features of these entities show why predefined entities are better than custom entities for standard problems.
Both date entities parse dates like 06.27.2020 correctly.
They are also capable of processing weekdays (Monday) and periods like Monday to Friday and tomorrow correctly.
It is possible to implement such behavior for a custom entity but is additional work
They also convert dates to the correct values.
If Monday is in the past for the span Monday to Friday, the resulting date period will be from the future Monday to Friday after next Monday.
The provided standard functionality for dates and date-spans is very convenient and user friendly.

When the slots are part of the training sentences, experienced users can shorten the workflow.
Usually, the user enters the required information slot by slot.
The user is not queried for a slot when the information is already present.
With these concepts, sending all the information with the first request is possible.
This speeds up the process for experienced users.
In a sentence like "Max Power is sick and will return Monday" all the required information is present, and the request can be processed immediately.
 

In general, custom entities are a list of entries or a list of entries with synonyms.
An advanced feature of Dialogflow is small-talk.
It can be enabled in the settings with a single click.
When small-talk is enabled, the bot responds to requests like "What are you", "Bye", and "sorry".
This is another useful feature of Dialogflow, which is predefined and requires no development effort. 

\subsection{Webhook}
The Dialogflow webhook requires an HTTP POST URL as an entry point.
The communication relies on JSON as a format.
Listing \ref{lst:dialogflow_entry_point} shows the entry point of the webhook.
A request (Listing \ref{lst:webhookExample}) can be accessed like a dictionary or an array shown in Listing \ref{lst:dialogflow_request_params} where the name of the intent gets extracted. 
After the intent has been extracted, the parameters are extracted to process the request.
In the error case, a new fulfillment message is returned.
A fulfillment message as return value prevents follow up intents.
In the success case, an empty response is returned, and the bot continues normally.
Listing \ref{lst:dialogflow_intent_handling} shoes a skeleton for intent handling for the success and error scenario of an intent called "Sickness Confirmed".

\begin{lstlisting}[caption={Dialogflow Webhook Entry Point}, label={lst:dialogflow_entry_point},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
@restService.route('/dialogflow/webhook', methods=['POST'])
def dialogflowRequestEntryPoint():
    return asJsonResponse(dialogflowRequestHandler()), 200
\end{lstlisting}  

\begin{lstlisting}[caption={Dialogflow Request Parameters}, label={lst:dialogflow_request_params},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
req = request.get_json(force=True)
intent = req.get('queryResult').get('intent').get('displayName')
\end{lstlisting}  

\begin{lstlisting}[caption={Dialogflow Intent Handling}, label={lst:dialogflow_intent_handling},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
if intent == 'Sickness Confirmed':
 params = req.get('queryResult').get('outputContexts')[0].get('parameters')
 employee_name = params.get('employee').get('name').lower()
 return_date = params.get('return_date')
 if !employeeExists(employee_name):
  return {
    "fulfillmentMessages": [
      {"text": {"text": ["Employee not found. Enter sick to retry."]}}
    ]
  } # RETURN ERROR MESSAGE
  else:
   db.store_sickness(employee_name, return_date) # PROCESS DATA
   return {} # CONTINUE NORMALLY
elif intent == 'Vacation':
    ...
\end{lstlisting}  
\makefigure{dialogflow_interface}{Dialogflow Web Interface}

% ----------------------------------------------------
% ---------------------- WATSON ----------------------
% ----------------------------------------------------
\section{Watson Assistant}
Watson Assistant\citet{watsonassistant} is the cloud chatbot technology of IBM hosted in the IBM cloud.
An IBM cloud account is required to use the services.
First, a new assistant needs to be created, which requires a name.
Then dialog skills can be created.
Figure \ref{fig:watson_interface} shows the web interface of Watson Assistant.
The interface offers the concepts intent, entity, and dialog.
A dialog node represents the actions when an intent is recognized.
The structuring of dialogs works the same way as with Dialogflow.

\subsection{Intents and Entities}
The required entities are person and date.
Watson Assistant offers system entities for persons and dates.
Watson uses the same concept as Dialogflow for communication with external services.
After entering a webhook URL in settings, the endpoint can be used in the application.

The person entity is marked deprecated and is available in English but not in German.
It is possible to create new entities by using examples or regular expressions.
IBM recommends the creation of a custom person entity with entity annotations in the test sentences to eliminate the deprecated person entity.
Every occurrence of person names in the test sentences needs to be highlighted and marked (annotated) as a person entity.
The sickness use-case requires a new intent. 
Then the training phrases are added to the intent.

A condition triggers a dialog node.
For the sickness use-case, the dialog node triggers every time the bot recognizes a sickness intent.
The settings menu of a dialog node offers customization options.
Customization options are slot filling and calling a webhook, for instance.
The sickness-notification use-case requires both options.
The required slots for the form filling are a person of type person and the return date of type date.
The person is mandatory, and the date is optional.
The webhook receives a request at the defined URL after the form-data collection.

\subsection{Dialog and Webhook}
The format of the webhook call is JSON.
The parameters need to be specified by hand.
The required parameters are the name of the intent, the person name, and the return date.
The name of the intent is necessary to execute the correct action at the webhook.
The name and the return date are the information stored in the backend for a successful request.
Listing \ref{lst:watson_request} shows that the requests of Watson Assistant contain no meta-information by default.
The developer defines the information and format submitted to the webhook.
The webhook returns a JSON object.
A context variable stores the JSON object.
It is accessible in the chatbot code like a regular struct in C++.

Based on the webhook response, the dialog can go in different ways.
It is possible to define a response for each possible response.
If the request only contained the name of a person, only the name of the person is present in the response message.
If the request contained a name and a date, both are present in the chatbots response message.
Whenever the webhook finds a person in the backend, the user needs to confirm that the entered information is correct.
If the person was not found the retry message is displayed
Watson Assistant offers conditional statements to handle such cases.

Table \ref{tab:watson_cond_response} shows the conditions, responses, and actions of the use case.
Chatbot responses can be picked sequentially, at random, or as a multiline response.
The multiline response displays all response lines at once.
The sequential version picks them in order, and the random variant picks the response at random from the available responses.
The confirmation logic is the next thing to implement.
No system entity or dialog for the confirmation logic is present.
Two intents or an entity are options to represent the confirmation.
An entity with two possible values (true, false) is a simple and logical approach.
The entity is called confirmation.
For these two cases, synonyms are defined like confirm, yes, and OK for true.
When the entity is detected, the correct path is selected based on the value.
The webhook response shown in Table \ref{tab:watson_cond_response} used similar logic.
The confirm or abort logic requires an additional dialog node.
The jump option in the settings of the dialog node allows a dialog node to be triggered based on the value of the variable.
For the confirm or abort dialog requires form-data and a webhook call after the confirmation.
Both options were enabled in the setting menu, like for the other nodes.
When the user aborts the operation, the webhook is not called.
The confirmation slot is of type confirmation entity and is required.
The webhook receives a request with the collected information.
If everything went fine, an all done message is displayed.
If something went wrong, an error message is displayed instead.
This ends the sickness dialog.

The vacation use-case is quite similar in structure.
The vacation use-case requires a date-span entity.
Watson Assistant offers no date-span entities, but it is possible to use two separate dates instead.
It is impossible to create compound entities with Watson.
A compound entity cloud store two dates. 
The options are to create an intent with two dates in it or a dialog node 
which fetches the required dates as form-data.
This thesis uses the dialog node approach because it comes close to the 
behavior implemented with Dialogflow.
A new dialog node named vacation is created.
For the dialog node, an intent called vacation is created with 
the example sentences.
The dialog needs a mandatory person slot and two mandatory date slots.
The date slots are the start and return dates of the vacation.
After the information has been collected the information can optionally 
be validated through the webhook.
Then the user needs to confirm the information like in the sickness use-case.
The confirmation dialog works the same way for both use-cases.
Then the final request is sent to the webhook, which stores the collected information.
The final all done message is displayed, and the vacation use-case is implemented.

\begin{table}[H]
    \centering
    \begin{tabular}{ l | l | l  }
  Condition & Chatbot Response & Jump To Action \\ \hline \hline
  \$response.OK \&\& \$date!=null & Please confirm \$person is sick & \multirow{2}{*}{Confirm or abort} \\
        & until \$date. & \\ \hline
  \$response.OK & Please confirm \$person is sick. & Confirm or abort \\ \hline
  \multirow{2}{*}{\$response.ERROR} & \$person not found. Enter sick to & \multirow{2}{*}{Wait for input} \\ 
  &  retry. & \\ \hline

\end{tabular}
    \caption{Conditional Responses of Watson Assistant} \label{tab:watson_cond_response}
\end{table} \noindent


\begin{lstlisting}[caption={Watson Assistant Request Format}, label={lst:watson_request},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
[{
        "intent": "Sick",
        "person_name": "Anna Nass",
        "return_date": "2020-05-27"
}]
\end{lstlisting}  

\makefigure{watson_interface}{Watson Assistant Web Interface}

% ----------------------------------------------------
% ----------------------  RASA  ----------------------
% ----------------------------------------------------
\section{Rasa}
Rasa\cite{rasa} is an open-source framework for NLU and chatbot implementation.
Rasa runs inside a Docker container or in a local Python environment.
Rasa uses Python as a development language and can be installed using pip.
Listing \ref{lst:rasa_compose} shows a Docker compose file for Rasa, and the action server. 
Rasa offers a standalone NLU application, the action server, and chatbot development.

Rasa consists of two parts for chatbot development.
The natural language part takes care of everything related to 
the conversation like intents, entities, the story, and the conversation flow.
The second part handles the slot filling and other actions.
For each part, a Docker image can be created.

The Docker compose file of \ref{lst:rasa_compose} can be used similarly for the Azure deployment in combination with the images.
Azure also offers a Docker registry to upload and pull custom images.
It is important to choose a compatible version of rasa and rasa-SDK.
The Rasa image is responsible for the NLU part and the Rasa sdk runs the 
actions server.
\begin{lstlisting}[caption={Rasa Docker Compose File}, label={lst:rasa_compose},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
version: '3.0'
services:
    rasa:
    image: rasa/rasa:1.4.6
    ports:
        - 80:5005
    networks: 
        - app_net
    volumes:
        - ./:/app
    command:
        run 
        --enable-api
        --cors *
    
    action_server:
    image: rasa/rasa-sdk:1.4.0    
    volumes:
        - ./actions:/app/actions
    expose: 
        - 5055
    networks: 
        - app_net
networks: 
    app_net:
\end{lstlisting}  
The information for a Rasa chatbot is scattered across multiple files.
The nlu.md file stores the intents with the utterances used for training.
Listing \ref{lst:rasa_intent_format} shows the format for intents.
\begin{lstlisting}[caption={Rasa Intent Format}, label={lst:rasa_intent_format},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
## intent:sick
    - My colleague [Max Power](PERSON) is sick until [Friday](date)
    - somebody is sick 
    - a colleague is ill today
\end{lstlisting} 
The stories.md file stores the stories. 
A story defines the flow of the dialog from start to end.
Listing \ref{lst:rasa_story_format} shows the sickness story.
\begin{lstlisting}[caption={Rasa Story Format}, label={lst:rasa_story_format},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={sickness, submit, affirm}]                
## Sickness Affirm
* sickness
    - sickness_form
    - form{"name":"sickness_form"}
* submit{"PERSON":"Anna Maria Mayer"}
    - sickness_form
    - slot{"PERSON":"Anna Maria Mayer"}
* submit{"time":"2020-05-30T00:00:00.000-07:00","DATE":"today"}
    - sickness_form
    - form{"name":null}
    - slot{"time":"2020-05-30T00:00:00.000-07:00"}
* affirm
    - action_submit_sickness_data
    - action_restart
\end{lstlisting} 
The actions.py file defines all the actions which are callable in the chatbot files.
The sickness form slot filling is one action, for instance.
The domain.yml file lists all intents, entities, and actions.
If they are not listed in the domain.yml file, they cannot be used in the application.
The defined actions can be simple utterances or something complex like the slot filling of a form.
In utterance actions, the response is chosen at random from the list of responses.
In the endpoints.yml file, the action server needs to be entered to use the actions server for slot filling.
The actions server runs separately from the NLU service at the standard port 5055.
The NLU service is accessible at default port 5005.

Rasa offers great freedom when it comes to configuration.
This is important because Rasa does not offer predefined entities as such.
However, spacy does offer the required date and person entities for the use cases.
Duckling is another option for data and date-span extraction.
In the config file shown in Listing \ref{lst:rasa_config}, the pipeline includes the spacy entity extractor and Duckling to enable the use of predefined entities.
\citet{spacyapi} lists the entities supported by Spacy under named entity recognition.
The entity recognition of spacy does work, but the dates are stored as they are.
The best case is when the date is converted in a standard format like 
Dialogflow and Watson Assistant do.
To gain access to a more powerful date parsing the Duckling\cite{duckling} Rasa Docker image is used.
Duckling converts entered dates and times to a standard format as the cloud services do.
It recognizes strings like "Monday" as dates and converts them correctly.
Duckling works similar to the date and date-span entities of Watson Assistant and Dialogflow.
The person entity of Spacy works as expected.
The used entities need to be added under entities in the domain.yml file. If they are not listed in the domain.yml file, they cannot be used in the application.
People with machine learning experience can define custom pipelines or adjust parameters of components.
Listing \ref{lst:spacy_pipeline_detail} shows the detailed pipeline used for this thesis.

The config file defines policies.
The form policy enables the use of forms, and the fallback policy enables a fallback action, which is triggered when the confidence score is below the defined threshold. 
In the sickness use case, a generic utterance is the fallback response. 

\begin{lstlisting}[caption={Rasa Configuration}, label={lst:rasa_config},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={language, pipeline, policies, name}]                
language: en
pipeline: 
    - name: "SpacyNLP"
    - name: "SpacyTokenizer"
    - name: "SpacyFeaturizer"
    - name: "RegexFeaturizer"
    - name: "DucklingHTTPExtractor"
        url: "http://localhost:8000"
    - name: "SpacyEntityExtractor"
    - name: "EntitySynonymMapper"
    - name: "SklearnIntentClassifier"
policies:
    - name: MemoizationPolicy
    - name: TEDPolicy
    - name: MappingPolicy
    - name: FormPolicy
    - name: FallbackPolicy
    nlu_threshold: 0.4
    core_threshold: 0.3
    fallback_action_name: action_default_ask_rephrase
\end{lstlisting} 
The general command required to work with Rasa are train, shell, run actions, and x.
The command "rasa train" trains Rasa with the current data.
The shell command starts an interactive shell to test the bot.
The action server needs to be run separately.
If Rasa-X is installed, the command "rasa x" starts a web UI.
Figure \ref{fig:rasa_x_interface} shows the UI of Rasa-X.
The web interface offers the files discussed in the training section (left) with additional features like the conversation graph (right) called flow for a story (middle) shown in Figure \ref{fig:rasa_x_interface}.
Rasa X offers interactive training where the chatbot is built through live interaction with the bot. 
Rasa stores a model every time it is trained.
This means the training history is available and old bots can be loaded.
If a feature does not work out, just load the old model.
\makefigure{rasa_x_interface}{Rasa X Interface}

For the sickness use-case, a new intent called sickness needs to be defined in the domain file.
The sickness intent needs slot filling, and the required entities are the 
person and the return date. 
The slots need to be defined in the slots section.
Every slot needs an utterance, which is named utter\_ask\_<SLOTNAME>.
The utterance is displayed when the bot asks for a slot.
Slot filling requires an action.
An example slot filling action is shown in Listing \ref{lst:slot_fill_action}.
The action needs the name function, which returns a unique name.
The required slots need to be defined.
The bot does not ask for unrequired slots.
The slot mappings function defines the type of the slots.
The submit function is called as soon as the slots have been filled.
In the submit function the collected information can be sent to the 
external endpoint, for instance.
Custom validation rules can be defined for each slot.
This can be used to validate that the entered person name exists.
Now the intent needs to be defined in the NLU file.
The sickness intent and the training phrases need to be defined in the 
NLU  file in the format of \ref{lst:rasa_intent_format}.
The entities are marked with square brackets and the types with parentheses.
Now the sickness story needs to be defined.
When a phrase is recognized which is classified as sickness intent then 
the slot filling needs to be triggered.
The next step is the confirmation dialog, where the user confirms the entered information.
A submit sickness data action is required.


To classify the response, the intent affirm and deny are created with some example phrases.
After affirm is recognized the confirmation action needs to be triggered.
In the run method of the submit action, the data can be validated and processed.
If deny is recognized the slots need to be cleared and a retry message needs to be displayed.
The sickness story for the successful cases is shown in Listing\ref{lst:rasa_story_format}.
The vacation use case is not different from the sickness use-case in Rasa.
The Duckling time entity can process times, time-spans, dates, and date-spans.
For Duckling there is no difference between a single date and a date-span.
Both are stored in the time slot and are of type time.
Hence, the same person and time slot of the sickness use-case can be used for the 
vacation use-case.
The response messages need to be adjusted.
For the vacation use-case, a new intent needs to be created in the domain file.
The vacation training phrases need to be listed in the NLU file.
A form and a submit action need to be created for the vacation intent.
The structure can be copied from the sickness use-case.
Then the response messages and conditions are adjusted as needed.
The actions need to be listed in the domain file to be usable in the stories.
Then the new stories need to be created.
With Rasa-X the stories are created with live interaction with the bot.
The stories are structured like in the sickness use-case.








% ----------------------------------------------------
% ----------------------  LUIS  ----------------------
% ----------------------------------------------------
\section{LUIS}
With LUIS\cite{luisdocs}, the language understanding service of Microsoft,
NLU services can be created.
NLU is only a part of a chatbot and it's not possible 
to create a chatbot with LUIS alone.
The chatbot features are available through the Microsoft bot services 
in combination with LUIS.
A LUIS account is necessary to create NLU services.
When a new project is created the name and a language need to be defined for 
the NLU application.
The chosen language is the language the users will use for the communication with the 
LUIS application.
The modification is done in the build tab.
\makefigure{luis_interface}{LUIS Web Interface}
The interface shown in Figure \ref{fig:luis_interface} offers intents and entities
like described in Chapter \ref{chap:basics}.
To create the NLU part with LUIS Table \ref{tab:conversation_data} will be used.
\ref{tab:conversation_data} defines the intents entities and response utterances
that need to be created in LUIS.
Figure \ref{fig:conversationflow} has no influence on LUIS because the 
conversation handling is not part of the NLU service.
To create an intent only a name and a list of training phrases (utterances) are necessary.
Multiple options are available to create different kinds of entities.
There are simple entities like e.g. a city.
They describe exactly one concept.
There are composite entities that are built from multiple entities (parts).
E.g. a ticket order entity could consist of an order number, the number of 
tickets, and the event.
An entity list is used when the valid items are limited like in the book hotel example.
There is only a limited number of valid hotel names and the list holds all valid 
hotels.
The invalid hotels are uninteresting in such a case.
Regular expressions\cite{regex} can also be used to define an entity.
It is also possible to add prebuilt entities and prebuilt domain entities.
The entities required for the sickness intent are person name and date. 
LUIS offers the prebuilt entities date-time and person-name.
This means no new entities need to be created for the sickness use-case
since the are prebuilt.
To test the NLU functionality two additional intents need to be created to 
simulate the conversation.
A submit name and a submit return date intent are required.
The submit name intent extracts the person name entity.
The submit return date entity extracts a date-time entity.
The advantage of predefined entities is the saved time and the 
advanced features.
The date-time entity is able to match inputs like Monday or tomorrow to 
a valid and correct date by default.
The year is also automatically added when the date e.g. first January lies in the past.
This is important for the vacation use case when the vacation is requested for 
the next year. 
