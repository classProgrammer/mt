\section{Dialogflow}
Dialogflow\cite{dialogflow} formerly known as API.ai is the chatbot framework of Google and 
is hosted in the Google cloud.
To create a new agent the main language needs to be selected and the name of the 
agent needs to be defined.
The selected language is the interaction language of the users.
Dialogflow offers the option to create a mega agent by combining other agents.
The web interface of Dialogflow is shown in Figure \ref{fig:dialogflow_interface} where 
the menu shows the intents and entities tabs.
Dialogflow supports the basic concepts of intents, entities, and utterances.
Hence, Table \ref{tab:conversation_data} is used for the implementation 
of the intents, entities, and utterances.
\subsection{Intents and Entities}
When a new intent is created some options are present.
A Dialogflow intent has training phrases, actions and parameters,
a response list, a context, and the fulfillment.
The training phrases are a list of utterances a users would enter.
Paramters are the slots which need to be filled in the conversation.
The parameters for the sickness intent are the rows of Table \ref{tab:example_sentences} where the entity cell is 
filled with text.
The response list is a list of utterances which is used to respond to the users question.
The context is used to pass parameter values to other intents.
In the fulfillment section the webhook can be enabled.
By default an intent is handled by dialogflow without communication to another service.
In the fulfillment section a webhook call can be enabled.
For the sickness intent two parameters are required.
The name of the person is a non-optional parameter,
the return date is an optional paramter.
Dialogflow provides many predefined entities and intents.
The date and person entities are predefined by Dialogflow and it's 
not necessary to create them.
Additionaly, yes and no intents are also available and can be used and 
adjusted for the current sickness notification use case.
The final structure is a sickness intent which is followed by either 
the yes or the no intent.
For this the follow up intent concept is used where follow ups can 
be entered.
At the end of the no intent the chatbot responds with a retry response.
At the end of the yes intent the bot responds with an all done response.
This ends the conversation of the sickness use case and the yes and no 
intent are marked as conversation ends.
The process looks the same for the vacation use case.
The vacation intent needs to be created and has a follow-up intent 
yes and no to confirm the user input.
The entities required are a person and a date-span.
Dialogflow offers a predefined entity called date-period wich offers this 
functionality and it's not required to create one.
The date and date-period entities offer advanced features.
A valid date period is for instance Monday to Friday.
This is transalted to the correct values if e.g. Monday is in the past
the resulting date period will be from the next Monday to the Friday 
which follows next Monday.
For the example sentences the entities can be used to create alternative ways to fill the slots.
The user can be prompted slot after slot or enter them in the first request to speed up the 
process for more experienced users.
In a sentence like "Max Power is sick and will return on Monday" all the required information is 
already in the sentence. 
The entities need to be defined in the training sentences.
Then the system learns that there alre multiple ways to acquire the information.
With suitable training sentences the chatbot can extract the information 
directly and jumps directly to the confirmation.  
In general, custom entities are defined as a list of entries or a list of entries with 
synonyms.
An advanced feature of Dialogflow is small talk which can be enabled in the settings.
When small talk is enabled the bot is able to respnd to things like "What are you",
"Bye", and "sorry".
This is another usefull feature which is predefined and requires no development effort
and can be enabled with one click. 

\subsection{Webhook}
The Dialogflow webhook requires a HTTP POST URL as entry point.
The communication relies on JSON as format.
The entry point of the webhook is shown in Listing \ref{lst:dialogflow_entry_point}.
A request like in Listing \ref{lst:webhookExample} can be accessed like a dictionary or 
an array shown in Listing \ref{lst:dialogflow_request_params} where the name of the 
intent gets extracted. 
After the intent has been extracted the paramters are extracted to process the request.
In the error case a new fulfillment message is returned.
A fulfillment message as return value prevents follow up intents.
In the success case an empty response is returned and the bot continues normally.
In Listing \ref{lst:dialogflow_intent_handling} a skeleton for intent handling
is shown for a success and error szenario for an intent called "Sickness Confirmed".

\begin{lstlisting}[caption={Dialogflow Webhook Entry Point}, label={lst:dialogflow_entry_point},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
@restService.route('/dialogflow/webhook', methods=['POST'])
def dialogflowRequestEntryPoint():
    return asJsonResponse(dialogflowRequestHandler()), 200
\end{lstlisting}  

\begin{lstlisting}[caption={Dialogflow Request Parameters}, label={lst:dialogflow_request_params},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
req = request.get_json(force=True)
intent = req.get('queryResult').get('intent').get('displayName')
\end{lstlisting}  

\begin{lstlisting}[caption={Dialogflow Intent Handling}, label={lst:dialogflow_intent_handling},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
if intent == 'Sickness Confirmed':
 params = req.get('queryResult').get('outputContexts')[0].get('parameters')
 employee_name = params.get('employee').get('name').lower()
 return_date = params.get('return_date')
 if !employeeExists(employee_name):
  return {
    "fulfillmentMessages": [
      {"text": {"text": ["Employee not found. Enter sick to retry."]}}
    ]
  } # RETURN ERROR MESSAGE
  else:
   db.store_sickness(employee_name, return_date) # PROCESS DATA
   return {} # CONTINUE NORMALLY
elif intent == 'Vacation':
    ...
\end{lstlisting}  

\makefigure{dialogflow_interface}{Dialogflow Web Interface}
\section{Watson Assistant}
To be done \cite{watsonassistant}.
 
\section{Rasa}
Rasa\cite{rasa} can either be used as a Docker container or 
it can be installed locally.
Rasa uses Python as development language and can be installed using pip.
A Docker compose file for Rasa and the action server is shown in listing 
\ref{lst:rasa_docker}.

\begin{lstlisting}[caption={Rasa Docker Compose File}, label={lst:rasa_docker},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
version: '3.0'
services:
    rasa:
    image: rasa/rasa:1.4.6
    ports:
        - 80:5005
    networks: 
        - app_net
    volumes:
        - ./:/app
    command:
        run 
        --enable-api
        --cors *
    
    action_server:
    image: rasa/rasa-sdk:1.4.0    
    volumes:
        - ./actions:/app/actions
    expose: 
        - 5055
    networks: 
        - app_net
networks: 
    app_net:
\end{lstlisting}  
The information for a Rasa chatbot is split in multiple files.
The nlu.md file stores the intents with the utterances used for training.
The intent format is shown in Listing \ref{lst:rasa_intent_format}
\begin{lstlisting}[caption={Rasa Intent Format}, label={lst:rasa_intent_format},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
## intent:greet
- hello
- hi 
- howdy
\end{lstlisting} 
The stories.md file stores the stories. 
A story defines the flow of the dialog.
An example story is shown in Listing \ref{lst:rasa_story_format}.
The user asks the bot if he is a bot and the bot executes the action 
which is an utterance.
\begin{lstlisting}[caption={Rasa Story Format}, label={lst:rasa_story_format},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
## general bot question
* are_you_a_bot
    - utter_i_am_a_bot
\end{lstlisting} 
All the actions are defined in actions.py.
The sickness form slot filling is an action for instance.


\section{LUIS}
With LUIS\cite{luisdocs}, the language understanding service of Microsoft,
NLU services can be created.
NLU is only a part of a chatbot and it's not possible 
to create a chatbot with LUIS alone.
The chatbot features are availiable through the Microsoft bot services 
in combination with LUIS.
A LUIS account is necessary to create NLU services.
When a new project is create a name and a language need to be defined for 
the NLU application.
The choosen language is the language the users will us for the communication with the 
LUIS application.
The modification is done in the build tab.
The interface shown in Figure \ref{fig:luis_interface} offers intents and entities
like described in Chapter \ref{chap:basics}.
To create the NLU part with LUIS Table \ref{tab:conversation_data} will be used.
\ref{tab:conversation_data} defines the intents entities and response utterances
which need to be created in LUIS.
Figure \ref{fig:conversationflow} has no influence on LUIS because the 
conversation handling is not part of the NLU service.
To create an intent only a name and a list of traing phrases (utterances) are necessary.
Multiple options are available to create different kinds of entities.
There are simple entities like e.g. a city.
They describe exactly one concept.
There are composite entities which are built from multiple entities (parts).
E.g. a ticket order entity could consist of a order number, the number of 
tickets, and the event.
An entity list is used when the valid items are limited like in the book hotel example.
There is only a limited number of valid hotel names and the list holds all valid 
hotels.
The invalid hotels are uninteresting in such a case.
Regular expressions\cite{regex} can also be used to define an entity.
It is also possible to add prebuilt entities and prebuilt domain entites.
The entities required for the sickness intent are person name and date. 
LUIS offers the prebuilt entities date-time and person-name.
This means no new entities need to be created for the sickness use-case
since the are prebuilt.
To test the NLU functionality two additional intents need to be created to 
simulate the conversation.
A submit name and a submit return date intent are required.
The submit name intent extracts the person name entity.
The submit return date entity extracts a date-time entity.
The advantage of predefined entities is the saved time and the 
advanced features.
The date-time entity is able to match inputs like Monday, or tomorrow to 
a valid an correct date by default.
The year is also automatically added when the date e.g. first Januarry lies in the past.
This is important for the vacation use case when the vacation is requested for 
the next year. 


\makefigure{luis_interface}{LUIS Web Interface}



\section{Azure Deployment}
\section{Frontend}
The main purpose of the frontend is the message handling.
It tracks the user input, submits the input to the chatbot service 
when the submit button is pressed, 
and displays the response.
A classic message in messangers has the properties sender, timestamp, and message.
The message format of the frontend is shown in Listing \ref{lst:message_format}
\begin{lstlisting}[caption={Message Format}, label={lst:message_format},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={}]                
messages.push({
    sender: "<Sender>",
    message: "<Message>",
    timestamp: this.getTimestamp()
})
\end{lstlisting}  
A toolbar with title, message area, and submit area are necessary for a messenger UI.
The structure is shown in Listing \ref{lst:messenger_structure}
\begin{lstlisting}[caption={Messenger Structure}, label={lst:messenger_structure},captionpos=b,frame=single,language={Python},commentstyle=\color{mygreen},keywordstyle=\color{blue},
    morekeywords={MessengerToolbar, MessageArea, Divider, MessengerSubmitArea, Box}]                
<Box width={"25em"}>
    <MessengerToolbar title="3 Banken IT Dev Chatbot" />
    <MessageArea entries={this.state.messages} />
    <Divider light />
    <MessengerSubmitArea 
        message={this.state.message} 
        textHandler={this.handleMessage.bind(this)} 
        submitMessage={this.handleSubmit.bind(this)} 
    />
</Box>
\end{lstlisting}  


The UI of the React messenger frontend is shown in action in Figure \ref{fig:messengerui}.
\section{Webhook}
\section{Local Deployment (maybe)}